#{
	Takes a piece of code written in Kalzit and converts much of it to JavaScript.
	This makes the code execution a little bit faster on modern browsers.
	
	At the moment, however, the conversion is really (really!) slow, so you should only use this function if there is much time.
	Also, you will still need the Kalzit runtime environment loaded to make the generated code actually work. It is not a standalone script!
	
	To transpile a simple "Hello World" program to JavaScript, you can do this (of course, it works with more complex code as well):
		
	calcitCompileJsFunction: {print: "Hello World"}.
}
$calcitCompileJsFunction = !{
	`Create basic tree from code`
	$createTree = $code fun {
		parseJson: code calcitCompile true `optimized`.
	}.
	
	$compileTreeToJsBase = $_tree fun {
		$compiledObject = _tree.
		
		`Separate the tree into sentences`
		$sentences ? ModifiableList = ().
		$currentSentence ? ModifiableList = ().
		($_node fun {
			!ifElse ($dot propOf _node) {
				($push propOf sentences): [getArray: currentSentence].
				do:($clear propOf currentSentence)
			};{
				($push propOf currentSentence): [_node]
			}
		}) each compiledObject.
		
		$lastSentence = getArray: currentSentence.
		!ifNot (void eq lastSentence) {
			($push propOf sentences): [getArray: lastSentence]
		}.
		
		`Assemble working JS base`
		$compiledSentences = compileSentence each getArray: sentences.
		$jsOutputBase = !ifElse (0 eq length: compiledSentences) {
			"return GLang.voidValue;"
		};{
			!ifElse (1 eq length: compiledSentences) {
				"return " + (first: compiledSentences) + ";"
			};{
				$firstSentences = (default: ""): ";" strJoin (0 to (length: compiledSentences) - 2) at compiledSentences.
				firstSentences + "; return " + (last: compiledSentences) + ";"
			}
		}
	}.
	
	
	`Compile each sentence`
	$compileSentence = $_sentence fun {
		$sentenceLength = length: _sentence.
		!ifElse (sentenceLength mod 2) {
			`Uneven number of elements`
			!ifElse (1 eq sentenceLength) {
				`Compile a single element`
				compileSingleNode: first: _sentence
			};{
				`Create function calls`
				!ifElse (sentenceLength eq 3) {
					`Actually create code`
					$functionNode = second: _sentence.
					$function = functionNode compileSingleNode true.
					
					$firstArgNode = first: _sentence.
					$firstArg = !ifElse ((":" eq $special propOf functionNode) | RepeatedFunction eq $type propOf calcitAnnotations: first: $argumentList propOf calcitAnnotations: resolveName: $name propOf functionNode) {
						firstArgNode compileSingleNode true.
					};{
						compileSingleNode: firstArgNode.
					}.
					$secondArgNode = third: _sentence.
					
					`Compose working JS`
					!ifElse (($fun eq $name propOf functionNode) & $string eq $kind propOf secondArgNode) {
						firstArg compileFunExpression secondArgNode
					};{
						"c([" + firstArg + ", " + (compileSingleNode: secondArgNode) + "]," + function + ")"
					}
					
				};{
					`Isolate last three elements`
					$functionNode = second: _sentence.
					$function = functionNode compileSingleNode true.
					
					$firstArgNode = first: _sentence.
					$firstArg = !ifElse ((":" eq $special propOf functionNode) | RepeatedFunction eq $type propOf calcitAnnotations: first: $argumentList propOf calcitAnnotations: resolveName: $name propOf functionNode) {
						firstArgNode compileSingleNode true.
					};{
						compileSingleNode: firstArgNode.
					}.
					$secondArg = compileSentence: ((3 to sentenceLength) - 1) at _sentence.
					
					`Compose working JS`
					"c([" + firstArg + ", " + secondArg + "]," + function + ")"
				}
			}
		};{
			!ifElse (sentenceLength eq 0) {
				"GLang.voidValue"
			};{
				`Isolate first element`
				$function = (first: _sentence) compileSingleNode true.
				$firstArg = compileSentence: (1 to sentenceLength - 1) at _sentence.
				
				`Compose working JS`
				"GLang.callObject(" + function + ", env, [" + firstArg + "])"
			}
		}
	}.
	
	$compileString = ($string ? String) fun {
		"str(" + (objToJson: string) + ")"
	}.
	$compileNameResolve = ($name ? String) fun {
		"rn(" + (objToJson: name) + ")"
	}.
	$compileNumber = ($num ? Float) fun {
		"{value:" + (objToJson: num) + "}"
	}.
	$compileParentheses = $_tree fun {
		"(function(){" + (compileTreeToJsBase: _tree) + "})()"
	}.
	$compileStringFunction = ($string ? String) fun {
		$jsBase = compileTreeToJsBase: createTree: string.
		$jsEnvironment = {
			var env = new GLang.RuntimeEnvironment(e);
			if(args.length >= 2) env.setInnerVariable("y", args[1]);
			if(args.length >= 1) env.setInnerVariable("x", args[0]);
			console.log(env);
		}.
		
		"{value:function(e, args){" + jsEnvironment + jsDefinitions + jsBase + "}}"
	}.
	$compileFunExpression = ($firstArgJs ; $_secondArgNode) fun {
		$mainFunction = calcitCompileJsFunction: $string propOf _secondArgNode.
		$closureContent = "var argList = " + firstArgJs + "; if(!(argList.value instanceof Array)){argList = {value:[argList]}}; var fun = " + mainFunction + ";".
		$valueWrap = {
			return {value:(function(){
				for(var i = 0; i < argList.value.length; i++){
					if((argList.value[i].value + "").startsWith("_")){
						return result;
					}
				}
				return GLang.arrayFun(result);
			})()};
		}.
		
		"(function(){" + closureContent + " var result = function(useless, args){return fun(GLang.createFunctionScope(env, argList, args))};" + valueWrap + "})()"
	}.
	
	$compileSingleNode = ($_node ; $asFunction) fun {
		do: first: (!switchEq ($kind propOf _node)
			["string";{
				!ifElse (1 eq asFunction) {
					compileStringFunction: $string propOf _node
				};{
					compileString: $string propOf _node
				}
			}];
			["special";{compileNameResolve: $special propOf _node}];
			["name";{compileNameResolve: $name propOf _node}];
			["num";{compileNumber: $num propOf _node}];
			["parentheses";{compileParentheses: $parentheses propOf _node}];
			["array";{"{value:[" + (compileParentheses: $array propOf _node) + "]}"}]
		);{
			`Default case`
			"null /*Can not compile single elements of type " + ($kind propOf _node) + " yet*/"
		}.
	}.
	
	`Create function with environment variables (env, c, rn, str)`
	$jsDefinitions = {
		function c(args, obj){return GLang.callObject(obj, env, args)};
		function rn(n){return env.resolveName(n)};
		function str(s){
			var str = GLang.stringValue(s);
			str.environment = env;
			return str;
		};
	}.
	
	`Assemble working JS string`
	$calcitCompileJsFunction = $code fun {
		$jsOutputBase = compileTreeToJsBase: createTree: code.
		"function(env){" + jsDefinitions + jsOutputBase + "}"
	}
}).