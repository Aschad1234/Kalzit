#!/usr/bin/env kalzit
`A http server that is specialized for the calcit web applications`
print "Starting the server ...".
print "Reading blacklist ...".
$blacklist = strNewline strSplit fileContent: "./nodejs/files/server/blacklist.txt".
print "Parsing internal library ...".

$blacklistAllows = $fname fun {not: 0 < sum: {x matches fname} each blacklist}.

$cachedUrlTitle = urlTitle cachedFun autoClearedCache: monthsToMillis: 2.
$servicesRegex = "\./services/([a-zA-Z0-9\-]+)/(.*)".

$redirects = (). $redirectsRef = reference: $redirects.
$findRedirect = $fname fun {
	first: {not: fname eq x} filter {
		((first: x);second: x) strReplace fname
	} each redirects
}.

$onClientConnect = ($_request fun {
	$fname = "." + first: "?" strSplit $url of _request.
	
	$result = void.
	$resultRef = reference: $result.
	$async = false.
	$asyncRef = reference: $async.
	
	!if ("./app/" strStartsWith fname) {
		$singlefile = "true" eq $sf urlGetParameter $url of _request.
		
		$appName = "./app/" strRemove fname.
		$appFileBase = !ifElse (fileIsFile: "apps/" + appName + ".redirect") {
				strFirstLine: fileContent: "apps/" + appName + ".redirect"
			};{
				"apps/" + appName
			}.
		
		$serveHtmlApp = $app fun {
			print: "Trying to run  HTML app " + app.
			asyncRef = true.
			($startServing of _request): "text/html".
			($writeFile of _request): app.
	        do:($endServing of _request).
		}.
		
		!ifElse (fileIsFile: appFileBase + "/" + appName + ".html"){
			serveHtmlApp: appFileBase + "/" + appName + ".html".
		};{
			!ifElse (fileIsFile: appFileBase + ".html") {
				serveHtmlApp: appFileBase + ".html".
			};{
				!if (fileIsFile: appFileBase + ".k") {
					print: "Trying to run Kalzit app " + $app = appFileBase + ".k".
					$appScript = 'GLang.evaluateTree(' + ((fileContent: app) calcitCompile true `optimized`) + ', GLang.defaultRuntimeEnvironment);'.
					!if singlefile {
						resultRef = ("$app$";appScript) strReplace fileContent: "./_browser_app_singlefile.html".
					}.
					!else {
						resultRef = ("$app$";appScript) strReplace fileContent: "./_browser_app.html".
					}
				}
			}
		}.
	}.
	
	!if ("./api/" strStartsWith fname) {
		$source = "./nodejs/files/server/api/" + ("./api/" strRemove fname) + ".k".
		!ifElse (fileExists: source) {
			print "Calling server API " + source.
			do: () fun fileContent: source.
		};{
			print "Server API " + source + " not found".
		}
	}.
	
	!if ("./docs/api/defaults/" strStartsWith fname)
        () fun fileContent: "./nodejs/files/server/showDocumentation.txt".
	
	!if ("./docs/api/home" eq fname){
		resultRef = "<br></br>" strJoin {'<a href="/docs/api/defaults/' + x + '">' + x + "</a>"} each do:pmListNames
	}.
	
	$m = servicesRegex match fname.
	!if (length: m){
		$serviceFile = "./nodejs/files/server/services/" + (second: m) + ".k".
		print "Generic service call detected: " + serviceFile.
		!if (fileIsFile: serviceFile) {
			do:() fun fileContent: serviceFile
		}
	}.
	
	$serveFile = $fname fun {
		`Check blacklist`
		!if (0 < sum: {x matches fname} each blacklist){
			print: "The following file is on the blacklist and will produce a 404 error page: " + fname.
           	($startServing of _request): fileMime: "html".
			($respondCode of _request): 404.
			_request httpEndServingRaw fileContentRaw: "./nodejs/files/server/404.html"
		}.
		`Find a file by name`
		!else {
			((fileIsFile: fname) & fileExists: fname) ifElse {
				print: "Serving file " + fname.
                ($startServing of _request): fileMime: fname.
				($writeFile of _request): fname.
                do:($endServing of _request).
			};{
				`Try finding a redirect`
				print "Trying to find redirect for " + fname.
				$redirect = findRedirect: fname.
				!ifElse (void eq redirect) {
					print: "Serving empty page for " + fname.
	                ($startServing of _request): fileMime: "html".
					($respondCode of _request): 404.
					_request httpEndServingRaw fileContentRaw: "./nodejs/files/server/404.html"
				};{
					serveFile: redirect
				}
			}
		}
	}.
	
	!if (not async) {
		!if (result eq void) {
			serveFile: fname
		}.
	    else {
	    	_request httpEndServingRaw strRaw: result
	    }
    }
	
}).


print "Reading .redirect files ...".
$searchFolderForRedirects = $folder fun {
	!if (blacklistAllows folder) {
		$content = folderContent: folder.
		
		`Return joined list`
		;/ ($entry fun {
			!ifElse (fileIsFolder entry) {
				searchFolderForRedirects: entry
			};{
				!if (".redirect" strEndsWith entry) {[
					("./" + ".redirect" strRemove entry);
					strFirstLine: fileContent: entry
				]}
			}
		}) each content.
	}.
}.
redirectsRef = searchFolderForRedirects: "./".

print "Start port listening ...".
!if (fileExists "./nogit/https/key.pem") {
    onClientConnect httpsServer 5001
}.
onClientConnect httpServer 5000.
print "Server is running now!".
print "------".
