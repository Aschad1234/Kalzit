#!/usr/bin/env kalzit
`A http server that is specialized for the calcit web applications`

print "Starting the server ...".
print "Reading blacklist ...".
$blacklist = strNewline strSplit fileContent: "./nodejs/files/server/blacklist.txt".
print "Parsing internal library ...".

$blacklistAllows = $fname fun {not: 0 < sum: {x isMatch fname} each blacklist}.

$cachedUrlTitle = urlTitle cachedFun autoClearedCache: monthsToMillis: 2.
$servicesRegex = "\./services/([a-zA-Z0-9\-]+)/(.*)".

$redirects = (). $redirectsRef = reference: $redirects.
$findRedirect = $fname fun {
	first: {not: fname eq x} filter {
		((first: x);second: x) strReplace fname
	} each redirects
}.

$onClientConnect = ($_request fun {
	$fname = {
		`Check for a folder, and if the requested file is a folder, search an index file`
		$file = x.
		print file.
		!ifElse (fileIsFolder: file) {
			`If the file is a folder`
			$indexFiles = {"index." strStartsWith fileName: x} filter folderContent: file.
			!ifElse (0 eq length: indexFiles){
				`No index file found`
				file
			};{
				`Return first index file`
				"./" + first: indexFiles
			}
		};{file}.
	}: "." + first: "?" strSplit $url propOf _request.
	
	$result = void.
	$resultRef = reference: $result.
	$async = false.
	$asyncRef = reference: $async.
	
	`Check blacklist`
	!ifElse (0 < sum: {x isMatch fname} each blacklist){
		print: "The following file is on the blacklist and will produce a 404 error page: " + fname.
       	($startServing propOf _request): fileMime: "html".
		($respondCode propOf _request): 404.
		_request httpEndServingRaw fileContentRaw: "./nodejs/files/server/404.html"
	};{
		`Hey, the requested file is not on the blacklist!`
		
		!if ("./app/" strStartsWith fname) {
			$appName = "./app/" strRemove fname.
			$appFileBase = !ifElse (fileIsFile: "apps/" + appName + ".redirect") {
					strFirstLine: fileContent: "apps/" + appName + ".redirect"
				};{
					"apps/" + appName
				}.
			
			$serveHtmlApp = $app fun {
				print: "Trying to run  HTML app " + app.
				asyncRef = true.
				_request httpWriteGlobalFile app.
		        do:($endServing propOf _request).
			}.
			
			!ifElse (fileIsFile: appFileBase + "/" + appName + ".html"){
				serveHtmlApp: appFileBase + "/" + appName + ".html".
			};{
				!ifElse (fileIsFile: appFileBase + ".html") {
					serveHtmlApp: appFileBase + ".html".
				};{
					!if (fileIsFile: appFileBase + ".k") {
						print: "Trying to run Kalzit app " + $app = appFileBase + ".k".
						$appScript = 'GLang.evaluateTree(' + ((fileContent: app) calcitCompile true `optimized`) + ', GLang.defaultRuntimeEnvironment);'.
						
						resultRef = ("$app$";appScript) strReplace fileContent: "./generated/_browser_app_singlefile.html".
					}
				}
			}.
		}.
		
		!if ("./api/" strStartsWith fname) {
			$source = "./nodejs/files/server/api/" + ("./api/" strRemove fname) + ".k".
			!ifElse (fileExists: source) {
				print "Calling server API " + source.
				do: () fun fileContent: source.
			};{
				print "Server API " + source + " not found".
			}
		}.
		
		$m = servicesRegex match fname.
		!if (length: m){
			$serviceFile = "./nodejs/files/server/services/" + (second: m) + ".k".
			print "Generic service call detected: " + serviceFile.
			!if (fileIsFile: serviceFile) {
				do:() fun fileContent: serviceFile
			}
		}.
		
		$languageRunnerFile = "./nodejs/files/server/languages/" + (fileExtension: fname) + ".k".
		!if (fileIsFile: languageRunnerFile) {
			!if (fileIsFile: fname) {
				print: "Trying to run a custom language with " + languageRunnerFile.
				do:() fun fileContent: languageRunnerFile
			}
		}.
		
		$serveFile = $fname fun {
			`Find a file by name`
			((fileIsFile: fname) & fileExists: fname) ifElse {
				print: "Serving file " + fname.
				!ifElse ("/static/" strContains fname) {
					_request httpWriteStaticFile fname
                };{
                	_request httpWriteGlobalFile fname
                }.
                do:($endServing propOf _request).
			};{
				`Try finding a redirect`
				print "Trying to find redirect for " + fname.
				$redirect = findRedirect: fname.
				!ifElse (void eq redirect) {
					print: "Serving empty page for " + fname.
	                ($startServing propOf _request): fileMime: "html".
					($respondCode propOf _request): 404.
					_request httpEndServingRaw fileContentRaw: "./nodejs/files/server/404.html"
				};{
					serveFile: redirect
				}
			}
		}.
		
		!if (not async) {
			!if (result eq void) {
				serveFile: fname
			}.
		    else {
		    	_request httpEndServingRaw strRaw: result
		    }
	    }
	    
    }
	
}).


print "Reading .redirect files ...".
$searchFolderForRedirects = $folder fun {
	!if (blacklistAllows folder) {
		$content = folderContent: folder.
		
		`Return joined list`
		;/ ($entry fun {
			!ifElse (fileIsFolder entry) {
				searchFolderForRedirects: entry
			};{
				!if (".redirect" strEndsWith entry) {
					$firstLine = strFirstLine: fileContent: entry.
					!ifElse ("" eq ("\s*";"") strReplaceRegex firstLine) {
						print: "Warning: " + entry + " is an empty redirect and will be ignored".
					};{[
						("./" + ".redirect" strRemove entry);
						strFirstLine: fileContent: entry
					]}
				}
			}
		}) each content.
	}.
}.
redirectsRef = searchFolderForRedirects: "./".

print "Start port listening ...".
!if (fileExists "./nogit/https/key.pem") {
    onClientConnect httpsServer 5001
}.
onClientConnect httpServer 5000.
print "Server is running now!".
print "------".
